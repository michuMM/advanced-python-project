<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <title>Statystyki - Wykresy</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: #121212;
            color: #eee;
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        .chart-container {
            width: 40%;
            max-width: 900px;
            margin: 30px auto;
            background: #222;
            padding: 20px;
            border-radius: 8px;
        }
        canvas {
            background-color: #333;
            border-radius: 6px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <button id="go-back" onclick="window.location.href='/'">← Wróć</button>
    <a href="/stats">Historia logowań</a>
    <h1>Statystyki - Wykresy</h1>

    <div class="chart-container">
        <h3>Średni czas szyfrowania i deszyfrowania wg algorytmu</h3>
        <canvas id="avgEncDecTime"></canvas>
    </div>

    <div class="chart-container">
        <h3>Udział algorytmów w liczbie wpisów</h3>
        <canvas id="algorithmShare"></canvas>
    </div>

    <div class="chart-container">
        <h3>Czas szyfrowania wg długości klucza</h3>
        <canvas id="encTimeByKeyLength"></canvas>
    </div>

    <div class="chart-container">
        <h3>Czas szyfrowania wg długości wiadomości</h3>
        <canvas id="encTimeByMsgLength"></canvas>
    </div>

    <div class="chart-container">
        <h3>Czas szyfrowania wg formatu pliku</h3>
        <canvas id="encTimeByFileFormat"></canvas>
    </div>

    <div class="chart-container">
        <h3>Czas szyfrowania wg akcji (register/login)</h3>
        <canvas id="encTimeByAction"></canvas>
    </div>

    <div class="chart-container">
        <h3>Rozkład statusów (success/fail)</h3>
        <canvas id="statusDistribution"></canvas>
    </div>

    <script>
    async function fetchStatsData() {
        const response = await fetch('/stats/data');
        if (!response.ok) throw new Error('Błąd pobierania danych');
        return response.json();
    }

    function average(arr) {
        if (arr.length === 0) return 0;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
    }

    function groupBy(arr, key) {
        return arr.reduce((acc, item) => {
            const k = item[key] ?? 'none';
            if (!acc[k]) acc[k] = [];
            acc[k].push(item);
            return acc;
        }, {});
    }

    function filterValidNumber(val) {
        return typeof val === 'number' && !isNaN(val);
    }

    function prepareEncTimeData(entries, groupKey) {
        const grouped = groupBy(entries, groupKey);
        const labels = Object.keys(grouped);
        const avgTimes = labels.map(label => {
            const filtered = grouped[label].map(e => e.encryptionTime).filter(filterValidNumber);
            return average(filtered);
        });
        return { labels, data: avgTimes };
    }

    function prepareStatusData(entries) {
        const counts = { success: 0, fail: 0, none: 0 };
        for (const e of entries) {
            if (e.status === 'success') counts.success++;
            else if (e.status === 'fail') counts.fail++;
            else counts.none++;
        }
        return counts;
    }

    (async () => {
        const data = await fetchStatsData();

        // 1. Średni czas szyfrowania i deszyfrowania wg algorytmu
        const groupedByAlg = groupBy(data, 'algorithm');
        const algLabels = Object.keys(groupedByAlg);
        const avgEncTimes = algLabels.map(alg => {
            const times = groupedByAlg[alg].map(e => e.encryptionTime).filter(filterValidNumber);
            return average(times);
        });
        const avgDecTimes = algLabels.map(alg => {
            const times = groupedByAlg[alg].map(e => e.decryptionTime).filter(filterValidNumber);
            return average(times);
        });

        const ctx1 = document.getElementById('avgEncDecTime').getContext('2d');
        new Chart(ctx1, {
            type: 'bar',
            data: {
                labels: algLabels,
                datasets: [
                    {
                        label: 'Średni czas szyfrowania (s)',
                        data: avgEncTimes,
                        backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    },
                    {
                        label: 'Średni czas deszyfrowania (s)',
                        data: avgDecTimes,
                        backgroundColor: 'rgba(255, 206, 86, 0.7)',
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 2. Udział algorytmów w liczbie wpisów (kołowy)
        const algCounts = {};
        for (const entry of data) {
            const alg = entry.algorithm ?? 'none';
            algCounts[alg] = (algCounts[alg] || 0) + 1;
        }
        const algShareLabels = Object.keys(algCounts);
        const algShareData = algShareLabels.map(l => algCounts[l]);

        const ctx2 = document.getElementById('algorithmShare').getContext('2d');
        new Chart(ctx2, {
            type: 'doughnut',
            data: {
                labels: algShareLabels,
                datasets: [{
                    data: algShareData,
                    backgroundColor: [
                        '#36A2EB',
                        '#FFCE56',
                        '#FF6384',
                        '#4BC0C0',
                        '#9966FF',
                        '#FF9F40'
                    ]
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 3a. Czas szyfrowania wg długości klucza
        const keyLengthData = prepareEncTimeData(data, 'keyLength');
        const ctx3a = document.getElementById('encTimeByKeyLength').getContext('2d');
        new Chart(ctx3a, {
            type: 'bar',
            data: {
                labels: keyLengthData.labels,
                datasets: [{
                    label: 'Średni czas szyfrowania (s)',
                    data: keyLengthData.data,
                    backgroundColor: 'rgba(75, 192, 192, 0.7)'
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 3b. Czas szyfrowania wg długości wiadomości
        const msgLengthData = prepareEncTimeData(data, 'messageLength');
        const ctx3b = document.getElementById('encTimeByMsgLength').getContext('2d');
        new Chart(ctx3b, {
            type: 'bar',
            data: {
                labels: msgLengthData.labels,
                datasets: [{
                    label: 'Średni czas szyfrowania (s)',
                    data: msgLengthData.data,
                    backgroundColor: 'rgba(153, 102, 255, 0.7)'
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 3c. Czas szyfrowania wg formatu pliku
        const fileFormatData = prepareEncTimeData(data, 'fileFormat');
        const ctx3c = document.getElementById('encTimeByFileFormat').getContext('2d');
        new Chart(ctx3c, {
            type: 'bar',
            data: {
                labels: fileFormatData.labels,
                datasets: [{
                    label: 'Średni czas szyfrowania (s)',
                    data: fileFormatData.data,
                    backgroundColor: 'rgba(255, 159, 64, 0.7)'
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 3d. Czas szyfrowania wg akcji
        const actionData = prepareEncTimeData(data, 'action');
        const ctx3d = document.getElementById('encTimeByAction').getContext('2d');
        new Chart(ctx3d, {
            type: 'bar',
            data: {
                labels: actionData.labels,
                datasets: [{
                    label: 'Średni czas szyfrowania (s)',
                    data: actionData.data,
                    backgroundColor: 'rgba(255, 99, 132, 0.7)'
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });

        // 4. Rozkład statusów
        const statusCounts = prepareStatusData(data);
        const ctx4 = document.getElementById('statusDistribution').getContext('2d');
        new Chart(ctx4, {
            type: 'bar',
            data: {
                labels: ['success', 'fail', 'none'],
                datasets: [{
                    label: 'Liczba wpisów',
                    data: [statusCounts.success, statusCounts.fail, statusCounts.none],
                    backgroundColor: [
                        'rgba(75, 192, 192, 0.7)',
                        'rgba(255, 99, 132, 0.7)',
                        'rgba(201, 203, 207, 0.7)'
                    ]
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#eee' } },
                    x: { ticks: { color: '#eee' } }
                },
                plugins: {
                    legend: { labels: { color: '#eee' } }
                }
            }
        });
    })();
    </script>
</body>
</html>
